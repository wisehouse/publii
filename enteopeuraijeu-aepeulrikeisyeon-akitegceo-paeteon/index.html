<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>엔터프라이즈 애플리케이션 아키텍처 패턴 - HAUS</title><meta name="description" content="저자 : 마틴 파울러 Martin Fowler 역자 : 최민석 엔터프라이즈 애플리케이션 아키텍처 패턴은 마틴 파울러가 수많은 패턴을 검토한 끝에 정리한 계층형 아키텍처에 대한 정리이다. 웹 기반의 애플리케이션을 만드는 사람이라면 누구나 한 번은 읽어봐야 할 책이다. 오래전에 읽었어야 하는 책을 이제야 만나게 되었다. 그 동안 다른&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://publii.wisehouse.kr/enteopeuraijeu-aepeulrikeisyeon-akitegceo-paeteon/"><link rel="alternate" type="application/atom+xml" href="https://publii.wisehouse.kr/feed.xml"><link rel="alternate" type="application/json" href="https://publii.wisehouse.kr/feed.json"><meta property="og:title" content="엔터프라이즈 애플리케이션 아키텍처 패턴"><meta property="og:site_name" content="HAUS"><meta property="og:description" content="저자 : 마틴 파울러 Martin Fowler 역자 : 최민석 엔터프라이즈 애플리케이션 아키텍처 패턴은 마틴 파울러가 수많은 패턴을 검토한 끝에 정리한 계층형 아키텍처에 대한 정리이다. 웹 기반의 애플리케이션을 만드는 사람이라면 누구나 한 번은 읽어봐야 할 책이다. 오래전에 읽었어야 하는 책을 이제야 만나게 되었다. 그 동안 다른&hellip;"><meta property="og:url" content="https://publii.wisehouse.kr/enteopeuraijeu-aepeulrikeisyeon-akitegceo-paeteon/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://publii.wisehouse.kr/assets/css/style.css?v=4128e7e1a641a287245dedc222b18c79"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://publii.wisehouse.kr/enteopeuraijeu-aepeulrikeisyeon-akitegceo-paeteon/"},"headline":"엔터프라이즈 애플리케이션 아키텍처 패턴","datePublished":"2022-08-04T00:22","dateModified":"2022-08-04T01:13","description":"저자 : 마틴 파울러 Martin Fowler 역자 : 최민석 엔터프라이즈 애플리케이션 아키텍처 패턴은 마틴 파울러가 수많은 패턴을 검토한 끝에 정리한 계층형 아키텍처에 대한 정리이다. 웹 기반의 애플리케이션을 만드는 사람이라면 누구나 한 번은 읽어봐야 할 책이다. 오래전에 읽었어야 하는 책을 이제야 만나게 되었다. 그 동안 다른&hellip;","author":{"@type":"Person","name":"Jung, Chul Woo","url":"https://publii.wisehouse.kr/authors/jung-chul-woo/"},"publisher":{"@type":"Organization","name":"Jung, Chul Woo"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://publii.wisehouse.kr/">HAUS</a></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2022-08-04T00:22">August 4, 2022</time></div><h1>엔터프라이즈 애플리케이션 아키텍처 패턴</h1><div class="post__meta post__meta--author"><a href="https://publii.wisehouse.kr/authors/jung-chul-woo/" class="feed__author">Jung, Chul Woo</a></div></div></header></div><div class="wrapper post__entry"><p>저자 : 마틴 파울러 Martin Fowler</p><p>역자 : 최민석</p><ul><li><p>엔터프라이즈 애플리케이션 아키텍처 패턴은 마틴 파울러가 수많은 패턴을 검토한 끝에 정리한 계층형 아키텍처에 대한 정리이다. 웹 기반의 애플리케이션을 만드는 사람이라면 누구나 한 번은 읽어봐야 할 책이다.</p><p>오래전에 읽었어야 하는 책을 이제야 만나게 되었다. 그 동안 다른 사람의 소스코드와 스스로의 생각으로만 만들어왔던 아키텍처를 이제야 다른 사람의 조언을 통해서 배우게 되었다. MVC라는 널리 알려진 패턴 추상적인 패턴만을 들어오다가 이를 실제로 어떻게 구현해야 하는지를 이제야 배우게 되었다. 내가 생각하는 것보다 훨씬 많은 패턴이 존재한다는 것을 알게 되었고, 앞으로도 지금 내가 알고 있는 것에 만족하지 않고, 또 내가 알고 있는 것만 고수하지 않고, 끊임 없이 다른 사람의 방법을 배우고 적용하는 일을 멈추지 말아야겠다는 생각을 하게 된다.</p><p>1부의 “이야기”를 통해서 사용할 <a href="https://publii.wisehouse.kr/paeteon/">패턴</a>을 결정하고, 2부의 사전을 통해서 패턴을 배우는 순서로 적용하면 될 것 같다.</p></li></ul><h1 id="1부-이야기"><strong>1부. 이야기</strong></h1><h2 id="1장-계층화"><strong>1장. 계층화</strong></h2><p>계층화는 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분할하는 데 사용하는 가장 일반적인 기법이다.</p><p>모든 계층형 아키텍처가 이렇게 불투명한 구조를 갖는 것은 아니지만 대부분이 그러하며, 또는 대부분이 거의 불투명한 구조를 갖는다.</p><h3 id="계층화의-장점"><strong>계층화의 장점</strong></h3><ul><li>다른 계층에 대한 정보 없이도 단일 계층을 하나의 일관된 계층으로 이해할 수 있다.</li><li>동일한 기본 서비스를 가진 대안 구현으로 계층을 대체할 수 있다.</li><li>계층 간의 의존성을 최소화할 수 있다.</li><li>계층은 표준화하기 좋은 위치다.</li><li>한 번 구축은 계층은 여러 다른 상위 서비스에서 사용할 수 있다.</li></ul><h3 id="계층화의-단점"><strong>계층화의 단점</strong></h3><ul><li>계층은 전체가 효과적으로 캡슐화되지 않는다. 그 결과, 뭔가를 변경했을 때 다른 계층에 영향을 미치는 경우가 있다.</li><li>계층을 추가하면 성능이 저하된다. 일반적으로 각 계층에서는 정보를 한 표현에서 다른 표현으로 변환해야 한다. 다만, 기반 기능을 캡슐화하면 성능 저하가 보상될 만큼 효율이 향상되는 경우도 많다.</li></ul><h3 id="1-엔터프라이즈-애플리케이션에서의-계층의-발전"><strong>1. 엔터프라이즈 애플리케이션에서의 계층의 발전</strong></h3><p>계층에 대해 이야기할 때 계층(layer)과 티어(tier)를 혼동하는 경우가 많다. 두 용어는 종종 같은 의미로 사용되지만, 일반적으로 티어는 물리적 분리를 함축하는 경우가 많다.</p><h3 id="2-세-가지-주요-계층"><strong>2. 세 가지 주요 계층</strong></h3><p>이 책에서는 프레젠테이션, 도메인, 데이터 원본이라는 세 가지 주요 계층으로 구성되는 아키텍처를 주로 다룬다 (이러한 계층의 이름은 [Brown et al.]에 나오는 이름을 차용했다).</p><p>프레젠테이션(presentation) 논리는 사용자와 소프트웨어 간 상호작용을 처리한다.</p><p>데이터 원본(data source) 논리는 애플리케이션을 대신해 다른 시스템과 통신한다.</p><p>나머지 논리는 비즈니스 논리라고도 하는 도메인 논리(domain logic)다. 이 논리는 애플리케이션이 수행하는 도메인과 관련된 작업니다.</p><p>도메인과 데이터 원본은 프레젠테이션에 의존하지 않아야 한다. 다시 말해 도메인이나 데이터 원본 코드가 프레젠테이션의 코드의 서브 루틴을 호출하면 안된다.</p><p>도메인 논리 작업에서 가장 어려운 점 중 하나는 도메인 논리와 다른 형태의 논리를 구분하기 어려운 경우가 많다는 것이다.</p><h3 id="3-계층이-실행될-위치-선택"><strong>3. 계층이 실행될 위치 선택</strong></h3><p>데이터 원본은 거의 항상 서버에서 실행된다.</p><p>프레젠테이션 계층을 실행하는 위치에 대한 결정을 주로 원하는 사용자 인터페이스의 유형에 따라 달라진다. 리치 클라이언트의 경우 거의 대부분 클라이언트에서 프레젠테이션 계층을 실행한다. 웹 인터페이스의 경우 거의 대부분 서버에서 실행한다.</p><p>다음은 도메인 논리다. 비즈니스 논리는 모두 서버에서 또는 모두 클라이언트에서 실행하거나 분할해서 실행할 수 있다. 이번에도 역시 모두 서버에서 실행하는 것이 유지 관리를 생각할 때 최선의 방법이다. 비즈니스 논리를 클라이언트로 옮기는 이유는 응답성을 개선하거나 비연결 작업을 지원하기 위해서다.</p><h2 id="2장-도메인-논리-구성"><strong>2장. 도메인 논리 구성</strong></h2><p>필자는 도메인 논리를 트랜잭션 스크립트, 도메인 모델, 테이블 모듈의 세 가지 주요 패턴으로 분리했다.</p><h3 id="트랜잭션-스크립트">트랜잭션 스크립트</h3><p>도메인 논리를 저장하는 가장 간단한 방식은 트랜잭션 스크립트다. 기본적으로 트랜잭션 스크립트는 프레젠테이션에서 입력을 받고, 유효성 검사와 계산을 통해 입력을 처리한 다음, 데이터베이스에 데이터를 저장하고, 다른 시스템에서 작업을 호출하는 프로시저다. 그런 다음 필요에 따라 응답을 구성하고 서식을 지정하는 계산을 더 수행하고 추가 데이터로 프레젠테이션에 응답한다.</p><p><strong>트랜잭션 스크립트의 장점</strong></p><ul><li>대부분의 개발자가 이해할 수 있는 간단한 절차적 모델이다.</li><li>행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 적용해서 데이터 원본 계층과 함께 사용하기에 적합하다.</li><li>트랜잭션의 경계를 설정하기 쉽다. 트랜잭션 열기아 함께 시작하고 트랜잭션 닫기와 함께 중요한다. 툴을 사용해 배후에서 이러한 작업을 하기도 쉽다.</li></ul><p><strong>트랜잭션 스크립트의 단점</strong></p><ul><li>도메인 논리가 늘어나면서 복잡도가 상승한다.</li><li>여러 트랜잭션이 비슷한 작업을 수행해야 하므로 코드가 많이 중복된다.</li><li>결과적으로 애플리케이션이 명확한 구조가 없는 얼키고설킨 루틴 뭉치가 된다.</li></ul><h3 id="도메인-모델">도메인 모델</h3><p>물론 복잡한 논리는 객체를 통해 해결할 수 있으며, 이 문제를 해결하기 위한 객체지향적 방법이 바로 도메인 모델이다. 도메인 모델을 이용할 때는 먼저 도메인에 있는 명사를 바탕으로 도메인과 비슷한 모델을 구축한다.</p><p>도메인 모델을 사용하는 데 따르는 비용은 사용의 복잡성과 데이터 원본 계층의 복잡성이다. 리치 객체 모델을 처음 시작하는 개발자가 도메인 모델에 익숙해지는 데는 시간이 필요하다.</p><p>도메인 모델이 풍성해질수록 관계형 데이터베이스 매핑도 복잡해진다.</p><h3 id="테이블-모듈">테이블 모듈</h3><p>도메인 논리 구조의 세 번째 선택은 테이블 모듈이 있다. 언뜻 보기에 테이블 모듈은 계약, 상품, 수익 인식 클래스를 가진다는 점에서 도메인 모델과 비슷해 보인다. 두 패턴의 가장 중요한 차이는 도메인 모델은 데이터베이스에서 각 계약마다 계약 인스턴스가 있지만, 테이블 모듈은 인스턴스가 단 하나라는 것이다.</p><p>테이블 모듈은 여러 면에서 트랜잭션 스크립트와 도메인 모델의 중간적인 성격을 많이 띤다. 프로시저로만 작업하기보다 테이블을 기본으로 도메인 논리를 구성하기 때문에 구조를 만들고 중복을 찾아 제거하기가 수월하다. 다만 상속, 전략, 그릭 다른 객체지향 패턴과 같인 도메인 모델에서 논리의 세부 구조를 만드는 데 사용하는 기법은 사용할 수 없다.</p><p>테이블 모듈의 가장 큰 장점은 아키텍처의 나머지 부분과 잘 맞는다는 것이다.</p><h3 id="1-선택"><strong>1. 선택</strong></h3><p>도메인 논리의 복잡도가 어느 정도 이상이면 도메인 모델을 사용하는 것이 바람직하지만, 도메인 논리의 복잡도를 측정하는 방법은 아무도 모른다는 것이 문제다.</p><p>개발팀이 도메인 모델에 익숙하다면 이 패턴을 사용하기 위한 초기 비용이 낮아진다. 다만 데이터 원본의 복잡성은 그대로기 대문에 다른 패턴보다는 여전히 초기 비용이 높다.</p><p>테이블 모듈에 대한 선호도는 환경에서 레코드 집합을 얼마나 잘 지원하느냐에 따라 달라진다. 레코드 집합을 지원하는 특수한 툴이 거의 없는 환경이라면 굳이 테이블 모듈을 사용할 이유가 없다.</p><p>이러한 세 패턴은 상호배타적인 선택은 아니다. 실제로 일부 도메인 논리에는 트랜잭션 스크립트를 사용하고 나머지 도메인 논리에는 테이블 모듈이나 도메인 모델을 사용하는 경우도 흔히 볼 수 있다.</p><h3 id="2-서비스-계층"><strong>2. 서비스 계층</strong></h3><p>도메인 논리를 처리하는 일반적인 방법은 도메인 계층을 둘로 나누는 것이다. 이 경우 서비스 계층을 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치한다. 이처럼 도메인 계층을 둘로 나눈 경우 프레젠테이션 계층은 애플리케이션의 API 역할을 하는 서비스 계층과 단독으로 상호작용한다.</p><p>서비스 계층은 명확한 API를 제공하며 트랜잭션 제어와 보안과 같은 기능을 넣기도 좋은 위치다. 즉, 서비스 계층의 각 메서드에 대한 트랜잭션과 보안 특성을 기술하는 간단한 모델을 활용할 수 있다.</p><p>서비스 계층을 사용할 때는 여기에 얼마나 많은 동작을 넣을 지 결정하는 것이 아주 중요하다.</p><h2 id="3장-관계형-데이터베이스-매핑"><strong>3장. 관계형 데이터베이스 매핑</strong></h2><p><strong>1. 아키텍처 패턴</strong></p><p>첫 번째 패턴 집합은 도메인 논리가 데이터베이스와 상호작용하는 방법을 좌우하는 아키텍처 패턴으로 구성되어 있다. 이러한 패턴의 선택은 전체 설계에 미치는 파급효과가 크고 리팩터랑하기 어렵기 때문에 충분한 주의를 기울여야 한다. 이 선택은 도메인 논리를 어떻게 설계 했느냐에 따라서도 영향을 받는다.</p><p>이러한 클래스를 구성하는 방법으로는 데이터베이스 테이블당 클래스 하나를 가지도록 데이터베이스 테이블의 테이블 구조를 바탕으로 클래스를 구성하는 것이 좋다. 이러한 클래스는 테이블의 게이트웨이가 된다.</p><p>게이트웨이를 사용하는 데는 크게 두 가지 방법이 있다. 가장 확실한 방법은 쿼리가 반환하는 각 행마다 인스턴스 하나를 만드는 것이다. 이를 행 데이터 게이트웨이라고 하며, 데이터에 대한 객체지향적 사고방식과 자연스럽게 잘 어울린다.</p><p>레코드 집합을 사용하는 경우 데이터베이스의 각 테이블마다 클래스가 하나만 있으면 된다. 그럼 3.2의 테이블 데이터 게이트웨이는 데이터베이스를 쿼리하고 레코드 집합을 반환하는 메소드를 제공한다.</p><p>테이블 데이터 게이트웨이는 레코드 집합과 아주 잘 어울리므로 테이블 모듈을 사용하는 경우에도 확실한 선택이다.</p><p>도메인 모델을 사용할 때는 몇 가지 추가 옵션이 있다. 도메인 모델에는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 함께 사용할 수 있다. 그러나 필자의 관점에서는 이러한 두 옵션은 간접성이 너무 많거나 부족하다.</p><p>간단한 애플리케이션에서 도메인 모델은 데이터베이스 테이블당 도메인 클래스 하나를 사용해 데이터베이스 구조에 아주 근겁하게 대응되는 간단한 구조다. 이러한 도메인 객체는 일반적으로 크게 복잡하지 않은 비즈니스 논리를 포함하는 경우가 많다. 따라서 그림 3.3과 같은 활성 레코드 구조를 통해 각 도메인 객체가 직접 데이터베이스 로드와 저장을 수행하는 것이 적절하다.</p><p>도메인 논리가 복잡해지면 점차 리치 도메인 모델에 가까워지고 활성 레코드의 간단한 접근법으로는 주체하지 못하게 된다.</p><p>이보다는 도메인 객체와 데이터베이스 테이블 간의 매핑을 간접 계층을 통해 완전히 처리해서 도메인 모델을 데이터베이스로부터 격리하는 것이 더 나은 방법이다. 그림 3.4의 데이터 매퍼는 데이터베이스와 도메인 모델이 서로 독립적으로 작동할 수 있게 중간에서 로딩과 저장을 대신 처리한다. 데이터 매퍼는 가장 복잡한 데이터베이스 매핑 아키텍처이며 두 계층을 완전한 격리라는 장점을 제공한다.</p><p>필자는 도메인 모델의 주요 지속성 메커지즘으로 게이트웨이를 추천하지 않는다. 도메인 논리가 간단하고 클래스와 테이블이 서로 비슷하게 대응된다면 활성 레코드가 간단한 방법이다. 더 복잡한 논리가 필요하다면 데이터 매퍼가 적합하다.</p><p><strong>2. 동작 문제</strong></p><p>동작 문제는 객체가 데이터베이스에 저장 및 로드되는 방법에 대한 것이다.</p><p>작업 단위는 이러한 두 문제를 해결하는데 꼭 필요한 패턴이다. 작업 단위는 데이터베이스에서 읽은 객체와 함께 이후 다양한 방법으로 수정한 객체를 추적하고 데이터베이스를 업데이트 한다. 작업 단위는 이처럼 데이터베이스와의 동작 상호 작용이 복잡할 때 필수적인 패턴이다.</p><p><strong>3. 데이터 읽기</strong></p><p>데이터를 읽을 때는 성능 문제가 크게 다가올 수 있다. 이를 위해 경험에 근거한 몇 가지 규칙을 알아두자.</p><p>가급적 여러 행을 한 번에 읽는다. 특히 같은 테이블에서 여러 행을 읽기 위해 반복적으로 쿼리하는 일이 없게 해야 한다.</p><p>데이터베이스 접근을 줄이는 다른 방법은 조인을 사용해 쿼리 하나로 여러 테이블을 한 번에 가져오는 것이다. 결과 레코드 집합은 이상해 보일 수 있지만 속도를 향상하는 데 큰 도움이 된다. 이 경우 여러 조인된 테이블의 데이터를 얻는 게이트웨이나 한 번에 호출도 여러 도메인 객체를 로드하는 데이터 매퍼를 사용할 수 있다.</p><p>다만, 조인을 사용할 때는 데이터베이스가 쿼리당 최대 3-4개의 조인을 처리하도록 최적화된다는 것을 염두에 둬야 한다. 캐시된 뷰를 이용하면 어느 정도 만회할 수는 있지만 조인을 너무 많이 사용하면 오히려 성능이 저하된다.</p><p><strong>4. 구조적 매핑 패턴</strong></p><p>대부분의 사람들은 객체-관계형 매핑을 이야기할 때 인메모리 객체와 데이터베이스 테이블을 매핑할 때 사용하는 구조적 매핑 패턴을 의미하는 경우가 많다. 이러한 패턴은 테이블 데이터 게이트웨이와는 거의 관계가 없지만 행 데이터 게이트웨이나 활성 레코드의 경우 몇 가지 패턴을 함께 사용할 수 있다. 그리고 데이터 매퍼의 경우 모든 패턴이 필요할 수 있다.</p><p><strong>관계 매핑</strong></p><p>객체와 관계형 데이터베이스가 연결을 처리하는 방법에는 차이가 있으며, 이 때문에 두 가지 문제가 발생한다. 첫째는 참조 방법의 차이다. 둘째, 객체는 컬렉션을 사용해 단일 필드로 손쉽게 여러 참조를 처리할 수 있는 반면 관계형은 정규화를 지원하기 위해 모든 연관 링크가 단일 값을 가져야 한다.</p><p>참조 방법의 차이를 해결하려면 각 객체의 관계형 식별자를 객체의 식별자 필드로 유지하고 이 값을 조회해 객체 참조와 관계형 키 간의 매핑을 처리하면 된다. 디스크에서 객체를 읽을 때는 식별자 맵을 관계형 키에서 객체로의 조회 테이블로 사용한다. 데이블에서 외래 키가 나올 때마다 외래 키 매핑을 사용해 객체 간 참조를 적절하게 구성한다. 식별자 맵에 키가 없을 때는 데이터베이스에서 가져오거나 지연 로드를 사용해야 한다.</p><p>컬렉션을 처리할 때는 앞에서 설명한 내용을 바탕으로 더 복잡한 버전의 외래 키 매핑이 필요하다. 객체에 컬렉션이 있는 경우 원본 객체의 ID와 연결딘 모든 행을 찾기 위해 다른 쿼리를 수행해야 한다. 컬렉션 객체가 컬렉션 소유자의 범위 외부에서 사용되지 않은 경우 의존 매핑을 활용해 매핑을 간소화할 수 있다.</p><p>양쪽 끝에 컬렉션이 있는 다대다 관계를 처리하려면 다른 방법이 필요하다. 관계형 데이터베이스는 이를 직접 처리할 수 없으므로 연관 테이블 매핑을 사용해 다대다 관계를 처리하는 새 관계형 테이블을 만들어야 한다.</p><p>외래 키로 변환될 객체 간 참조에는 식별자 필드가 사용되지만 모든 객체 참조를 이 방법으로 저장해야 하는 것은 아니다. 즉, 값 객체의 모든 필드를 연결된 객체에 포함 값으로 넣으면 된다.</p><p><strong>상속</strong></p><p>관계형 데이터베이스에서 문제가 되는 또 다른 유형의 계층으로 상속으로 연결된 클래스 계층이 있다. SQL에는 상속을 처리하는 표준적인 방법이 없기 때문에 이 경우에도 매핑을 이용해야 한다. 상속 구조를 처리하는 세 가지 방법으로는 계층의 모든 클래스에 대해 테이블 하나를 사용하는 단일 테이블 상속, 각 클래스당 테이블 하나를 사용하는 구현 테이블 상속, 그리고 계층의 클래스당 테이블 하나를 사용하는 클래스 테이블 상속이 있다.</p><p>각 방법의 장단점은 모두 자료구조의 중복과 접근 속도의 차이에 있다. 클래스 테이블 상속은 클래스와 테이블 간의 관계를 가장 단순하게 저장하지만 단일 객체를 로드하기 위해 여러 번 조인을 수행해야 하므로 일반적으로 성능이 낮다. 구현 테이블 상속은 조인 없이 한 객체를 한 테이블에서 가져올 수 있지만 변경에 취약하다. 다만 상위 클래스 테이블에서의 잠금 경합은 감소한다. 일부 데이터베이스에서는 공간 낭비가 단일 테이블 상속의 가장 큰 단점일 수 있다. 단일 테이블 상속의 다른 문제는 크기 때문에 접근 시 병목현상이 발생할 수 있다는 것이다. 반면 가장 큰 장점은 모든 정보를 한 곳에 저장하므로 수정하기 쉽고 조인이 필요 없다는 것이다.</p><p>이러한 세 패턴은 상호 배타적이지 않으므로 한계층에서 여러 패턴을 혼합할 수 있다.</p><p><strong>5. 매핑</strong></p><p>관계형 데이터베이스로 매핑할 때는 기본적으로 세 가지 상황 중 하나에 해당한다.</p><ul><li>스키마를 직접 선택할 수 있다.</li><li>기존의 스키마로 매핑해야 하며, 스키마를 변경할 수 없다.</li><li>기존의 스미카로 매핑해야 하지만 합의를 통해 스키마를 변경할 수 있다.</li></ul><p>가장 간단한 경우는 스키마를 직접 만들며, 중간 또는 낮은 복잡도의 도메인 논리를 위해 설계에 트랜잭션 스크립트나 테이블 모듈을 사용하는 경우다. 이 경우 전통적인 데이터베이스 설계 기법을 사용해 데이터 중심으로 테이블을 설계할 수 있다. 도메인 논리에서 SQL을 가져오는 데는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 사용한다.</p><p>도메인 모델을 사용할 때는 데이터베이스 설계와 비슷한 설계를 조심해야 한다. 즉, 데이터베이스를 염두에 두지 말고 도메인 논리를 간소화하는 데 집중하면서 도메인 모델을 구축한다. 데이터 매퍼는 유연성이 가장 높지만 더 복잡하다. 데이터베이스 설계가 도메인 모델과 같은 구조라면 활성 레코드를 대신 사용하는 것을 고려해본다.</p><p>모델을 먼저 구성하는 것이 합리적이라고 했지만 이를 위해서는 개발 반복 주기가 단기여야 한다. 모든 특정한 작업 내에서는 도메인 모델을 먼저 고려해야 하며, 진행하면서 도메인 모델의 각 부분을 데이터베이스에 통합해야 한다.</p><p>스키마가 이미 있는 경우 선택은 비슷하지만 과정은 약간 다르다. 도메인 논리가 간단할 때는 데이터베이스를 모방하는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이 클래스를 만들고 이 위에 도메인 노리를 배치한다. 도메인 논리가 복잡할 때는 도메인 모델이 필요하며 이 도메인 모델은 데이터베이스 설계와는 일치하지 않을 가능성이 높다. 따라서 도메인 모델을 점진적으로 구축하면서 데이터를 기존 데이터베이스에 저장할 데이터 매퍼를 포함하면 된다.</p><p><strong>이중 매핑</strong></p><p>가끔은 둘 이상의 데이터 원본에서 같은 종류의 데이터를 가져와야 하는 경우가 있다. 첫째는 여러 데이터베이스에 동일한 데이터가 포함되지만 복사/붙여넣기 재사용 방법 땨문에 스키마에 약간의 차이가 있는 경우다. 둘째는 다른 메커니즘으로 저장하는 경우인데, 데이터를 때로는 데이터베이스에 저장하고 때로는 메시지에 저장할 수 있다. 또한 XML 메시지, CICS 트랜잭션, 그리고 관계형 테이블에서 비슷한 데이터를 가져와야 할 수 있다.</p><p>가장 간단한 방법은 데이터 원본마다 하나씩, 매핑 계층을 여러 개로 만드는 것이다. 이 경우 2단계 매핑 스키마를 고려할 수 있다. 첫 번째 단계는 데이터를 인메모리 스키마에서 논리적 데이터 저장소 스키마로 변환한다. 논리적 데이터 저장소 스키마는 데이터 원본 포맷의 유사성을 극대화하도록 설계된다. 두 번째 단계는 논리적 데이터 저장소 스키마에서 실제 물리적 데이터 저장소 스키마로 매핑한다.</p><p>이 추가 단계는 데이터 간의 공통점이 많을 때만 가치가 있으므로 데이터는 비슷하지만 물리 데이터 저장소에 차이가 있어 불편한 경우에만 이중 매핑을 사용해야 한다.</p><p><strong>6. 데이터베이스 연결</strong></p><p>연결은 만드는 비용이 크든 작든 관리가 필요하다. 연결은 관리하는 데 비용이 많이 드는 자원이므로 사용이 끝나면 즉시 닫아야 한다. 또한 트랜잭션을 사용할 때는 일반적으로 특정 트랜잭션 내의 모든 명령을 동일 한결에 대해 수행해야 한다.</p><p>연결이 필요한 모든 곳에서 연결을 확보하는 방법은 두 가지다. 첫째는 연결을 명시적인 매개변수로 전달하는 것이다. 이 방법의 문제는 불필요하게 모든 종류의 메서드 호출에 연결을 함께 전달해야 한다는 것이다. 물론 이 문제는 레지스트리를 사용해 해결할 수 있다. 그리고 다중 스레드가 동일한 연결을 사용하지 않게 스레드 범위의 레지스트리를 사용해야 한다.</p><p>메모리도 연결과 비슷하게 사용이 끝나면 반환해야 하는 자원이다.</p><p>연결은 트래잭션과 밀접하게 관련되므로 트랜잭션과 함께 연결을 관리하는 것이 좋은 방법이다. 이처럼 트랜잭션과 연결을 함께 관리하는 데는 작업 단위가 적합하다.</p><p>트랜잭션 바깥에서 작업의 경우 각 명령마다 새로운 연결을 사용한다.</p><p><strong>7. 기타 주의사항</strong></p><p><strong>8. 참고 자료</strong></p><p>데이터베이스 매핑을 사용할 때 한 가지 다행스러운 점은 활용할 수 있는다. 훌륭한 아이디어가 굉장히 많다는 것이다. 권장할 만한 지식의 보고로는 [Brown-Whitenack], [Ambler], [Yoder], [Keller-Coldewey] 등이 있다.</p><p><strong>4장. 웹 프레젠테이션</strong></p><p>모델 뷰 컨트롤러는 자주 언급디지만 잘못 이해되는 경우가 많다. 따라서 필자는 모델 뷰 컨트롤러에서는 컨트롤러 대신 입력 컨트롤러라는 용어를 선호한다.</p><p>입력 컨트롤러는 요청을 받고 요청에서 정보를 꺼낸다. 그런 다음 비즈니스 논리를 적절한 모델 객체로 전달한다. 모델 객체는 데이터 원본 객체와 통신하고 요청에 명시된 모든 작업을 수행한 다음 응답에 필요한 정보를 수집한다. 그리고 작업이 완료되면 입력 컨트롤러로 제어를 반환한다. 입력 컨트롤러는 결과를 조사하고 응답을 표시하는 데 필요한 뷰를 결정한다. 입력 컨트롤러는 응답 데이터와 함께 제어를 뷰로 전달한다.</p><p>모델 뷰 컨트롤러를 적용하는 첫번째 이유이자 가장 중요한 이유는 모델을 웹 프레젠테이션으로부터 완전히 분리하기 위해서다.</p><p>여러 사용자 인터페이스 설계에서는 프레젠테이션 객체를 도메인 객체로부터 분리하기 위해 애플리케이션 컨트롤러 객체라는 중간 객체를 사용한다. 애플리케이션 컨트롤러는 애플리케이션의 흐름을 처리하고 어떤 화면을 어떤 순서로 표시할지 결정하는 역할을 한다. 이 계층은 프레젠테이션 계층의 일부로 보일 수도 있지만 프레젠테이션과 도메인 계층을 조정하는 별도의 계층으로 생각할 수 있다.</p><p>모든 시스테에 애플리케이션 컨트롤러가 필요한 것은 아니다. 애플리케이션 컨트롤러는 시스템에 화면 순서와 화면 간 이동과 관련된 논리가 많은 경우 유용하며, 페이지와 도메인의 작업 간에 간단한 메핑이 없는 경우에도 유용하다.</p><p><strong>1. 뷰 패턴</strong></p><p>뷰 쪽에서는 변환 뷰, 템플릿 뷰, 2단계 뷰라는 세 가지 패턴을 고려해야 한다. 먼저 변화 뷰나 템플릿 뷰 중 어떤 것을 사용할지 결정한 다음, 이 패턴에서 1단계 뷰 또는 2단계 뷰 중 어떤 것을 사용할지 결정해야 한다. 변환 뷰와 템플릿 뷰의 기본 패턴은 한 단계다. 2단계 뷰는 두 패턴에 적용할 수 있는 변형이다.</p><p>템플릿 뷰를 사용하면 페이지 구조 안에 프레젠테이션을 작성하고 페이지에 표식을 삽입해 동적 콘텐츠를 넣을 위치를 지정할 수 있다.</p><p>변환 뷰는 변환 스타일의 프로그램을 사용한다.</p><p>절차형 스크립트를 뷰로 사용하는 경우 변환 뷰나 템플릿 뷰 중 하나를 선택하거나 둘을 혼합한 흥미로운 스타일</p><p>1단계 뷰는 일반적으로 애플리케이션 화면당 뷰 컴포넌트 하나를 사용한다. 서로 비슷한 논리적 화면에 뷰를 공유하는 경우는 있지만 이 경우에도 화면당 뷰 하나가 사용된다고 간주한다.</p><p>2단계 뷰는 이 과정을 도메인 데이터로부터 논리적 화면을 생성한 다음 이를 HTML로 렌더링하는 두 단계를 나눈다.</p><p>2단계 뷰의 장점은 사용할 HTML에 대한 결정을 한 곳으로 모을 수 있다는 것이다. 이렇게 하면 한 객ㅊ만 변경하면 사이트의 모든 화면을 변경할 수 있으므로 HTML 전체를 쉽게 변경할 수 있다.</p><p>2단계 뷰는 기본적으로 동일한 기본적으로 서비스를 여러 프런트엔드 고객이 이용하는 웹 애플리케이션에서 더욱 잘 작동한다.</p><p><strong>2. 입력 컨트롤러 패턴</strong></p><p>입력 컨트롤러에는 두 가지 패턴이 있다. 가장 일반적인 패턴은 웹 사이트의 모든 페이지마다 입력 컨트롤러 객체를 만드는 것이다. 간단한 예로는 페이지 컨트롤러가 뷰와 입력 컨트롤러의 역할을 결합한 서버 페이지 하나인 경우다. 프런트 컨트롤러는 이 분리를 한단계 더 발전 시켜서 하 ㄴ객체가 모든 요청을 처리하게 한다. 이 단일 처리기는 URL을 해석해 요청의 유형을 파악하고 이를 처리할 별도의 객체를 생성한다.</p><p><strong>3. 참고 자료</strong></p><p>[Brown et al.]의 9장은 자바 웹 설계에 대한 훌륭한 내용을 담고 있다. [Alur et al.]은 추가적인 패턴에 대한 좋은 참고 자료이며, 여기서 소개하는 패턴은 자바 외의 환경에서도 활용할 수 있다. 입력 컨트롤러와 애플리케이션 컨트롤러의 용어를 구분하는 아이디어는 [Knight and Dai]에서 얻었다.</p><h2 id="5장-동시성"><strong>5장. 동시성</strong></h2><p>동시성은 테스트하기 어렵다. 자동화 테스트는 소프트웨어 개발의 기반으로서 중요한 역할을 하지만 동시성 문제를 확실하게 해결할 수 있는 테스트를 만들기는 어렵다.</p><p>엔터프라이즈 개발자가 동시성에 대한 안일한 관점을 갖는 이유는 트랜잭션 관리자가 있기 때문이다. 트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다.</p><p>그러나 단일 데이터베이스 트랜잭션에 넣을 수 없는 시스템가의 상호작용이 많이 때문에 동시성 문제를 완전히 무시할 수 있는 것은 아니다. 데이터가 여러 트랜잭션에 걸쳐 조작되는 경우 개발자가 직접 동시성을 관리해야 하기 때문이다. 여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성 제어를 오프라인 동시성이라고 한다.</p><p>엔터프라이즈 개발자가 해결해야 하는 두 번째 까다로운 동시성 문제는 다중 스레드를 지원하는 애플리케이션 서버 시스템에 대한 것이다.</p><p><strong>1. 동시성 문제</strong></p><p>손실된 업데이트는 이해해야 할 가장 간단한 개념이다. 일관성 없는 읽기는 올바르지만 한편으로 올바르지 않은 정보의 두 조각을 읽은 경우 발생한다. 이러한 두 가지 문제는 정확성(또는 안전성)을 위반하는 잘못된 동작을 유발하지만 두 사람이 동시에 동일한 데이터를 사용하려고 하지 않는다면 애초에 발생하지 않는다. 모든 동시성 프로그래밍의 핵심적 문제는 정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를 나타내는 홛동성을 충족해야 한다는 것이다. 그런데 세상에 공짜란 없듯이 원래 문제만큼 심각하지는 않아도 모든 해결책에는 각기 문제점이 있다.</p><p><strong>2. 실행 컨텍스트</strong></p><p>세션은 클라이언트와 서버 간에 오랫동안 실행되는 상호작용이다.</p><p>운영체제와 관련된 두 가지 중요한 용어로 프로세스와 스레드가 있다. 프로세스는 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행 컨텍스트다. 스레드는 한 프로세스 내에서 여러 스레드로 작동할 수 있게 구성된 소규모의 활성 에이전트다. 스레드는 한 프로세스 안에서 여러 요청을 지원할 수 있어 효율적 자원 활용에 도움이 도므르 더 선호된다. 그러나 스레드는 일반적으로 메모리를 공유하기 때문에 동시성 문제를 유발할 수 있다.</p><p><strong>3. 격리와 불변성</strong></p><p>엔터프라이즈 애플리케이션에서는 격리와 불변성이라는 두 가지 해결책이 특히 중요하다.</p><p>이 문제(동시성 문제)를 해결하는 한 가지 방법은 격리를 통해 데이터를 분리함으로써 하나의 활성 에이전트만 데이터에 접근할 수 있게 하는 것이다.</p><p>격리는 오류 발생 가능성을 낮추는 필수 기법이다. 훌륭한 동시성 설계란 이러한 격리 환경을 만드는 방법을 찾고 이 환경 내에서 최대한 많은 프로그래밍 작업을 수행하는 것이다.</p><p>동시성 문제는 공유하는 데이터가 수정될 수 있을 때만 발생한다. 따라서 변경 불가능한 데이터를 이닉할 수 있으면 동시성 충돌을 예방할 수 있다.</p><p><strong>4. 낙관적 동시성 제어와 비관적 동시성 제어</strong></p><p>격리할 수 없는 변경 가능한 데이터는 어떻게 해야할까? 이러한 데이터는 낙관적 동시성 제어와 비관적 동시성 제어라는 두 가지 방법으로 제어할 수 있다.</p><p>낙관적 잠금을 사용하는 경우에는 두 사용자가 모두 자유롭게 파일을 복사하고 편집할 수 있다. 비관점 잠금을 사용하는 경우 먼저 파일을 체크아웃하면 다른 사용자가 파일을 편집할 수 없게 된다.</p><p>간단하게 정리하면 낙관적 잠금은 충돌 감지에 해당하며, 비관점 잠금은 충돌 예방에 해당한다.</p><p>두 방식은 각기 장단점이 있다. 비관적 잠금의 단점은 동시성이 제한된다는 것이다.</p><p>낙관점 잠금과 비관적 잠금을 선택하는 가장 중요한 기준은 충돌의 빈도와 심각도다. 충돌이 자주 발생하지 않거나 그 결과가 그리 심각하지 않다면 더 나은 동시성을 제공하고 구현하기도 쉬운 낙관적 잠금을 선택해야 한다. 그러나 충돌의 결과가 사용자에게 심각한 경우에는 비관적 잠금을 사용해야 한다.</p><p><strong>일관성 없는 읽기 예방</strong></p><p>이 문제는 근본적으로 일관성 없는 읽기 문제지만 사람들은 동시성 문제에 의해 손실된 업데이트에 집중하느라 일관성 없는 읽기 문제를 놓치는 경우가 많다. 그런데 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 이 문제를 매끄럽게 해결할 수 있다.</p><p>낙관적 잠금의 충돌 감지 기능은 일반적으로 데이터에 넣은 일종의 버전 표식을 기반으로 작동한다. 이 표식은 타임스탬프나 순차 카운터일 수 있다.</p><p>일관성 없는 읽기를 해결하는 또 한 가지 방법은 임시 읽기를 이용하는 것이다.</p><p><strong>교착 상태</strong></p><p>비관적 잠금 기법에서 발생할 수 있는 특수한 문제로 교착 상태가 있다.</p><p>교착 상태를 해결하는 다양한 기법이 이다. 그 중 하나는 교착 상태가 발생하면 감지할 수 있는 소프트웨어를 사용하는 것이다. 또 다른 하나는 모든 잠금에 시간 제한을 두는 방식이 있다.</p><p>시간 제한과 감지 기법은 모두 교착 상태가 발생하면 해결하는 기법이다.  교착 상태가 아예 발생하지 않게 예방하는 다른 기법이 있다. 작업을 시작할 때 필요한 잠금을 모두 얻게 하고 추가 잠금을 얻지 못하게 하면 교착 상태를 예방할 수 있다.</p><p>사용자가 잠금을 얻는 순서에 대한 규칙을 지정할 수 있다.</p><p>또한 데이비드가 이미 가지고 있는 잠금을 마틴이 얻으려고 하면 자동으로 마틴이 희생자가 되게 하는 방법도 있다 극단적이지만 간단하게 구현할 수 있으며, 생각보다 다양한 상황에 잘 적용된다.</p><p><strong>5. 트랜잭션</strong></p><p>첫째, 트랜잭션은 시작점과 끝점이 명확하게 정의된 일련의 작업이다. 관련된 모든 자원은 트랜잭션이 시작하고 끝날 때 모든 일관된 상태로 유지된다.</p><p>또한 모든 트랜잭션은 전체를 실행하거나 실행하지 않는 양자택일 방식으로 수행해야 한다.  위의 트랜잭션에서 인간적 요소에 의해 이 마지막 속성이 선태 사항이 될 수는 있지만 소프트웨어가 이를 보장하지 못할 이유는 없다.</p><p><strong>ACID</strong></p><ul><li>원자성 (Atomicity)</li><li>일관성 (Consistency)</li><li>격리성 (Isolation)</li><li>지속성 (Durability)</li></ul><p><strong>트랜잭션 리소스</strong></p><p>따라서 트랜잭션에 대한 기술적 논의에서는 트랜잭션으로 동시성을 제어할 수 있는 모든 대상을 나타내는 데 “트랜잭션 리소스”라는 용어를 사용한다. “트랜잭션 리소스”는 다소 복잡하므로 이 책에서는 가장 일반적인 “데이터베이스”라고 할 것이다.</p><p>처리량을 극대화하기 위해 최신 트랜잭션 시스템은 트랜잭션을 최대한 짧게 유지하도록 설계된다. 따라서 여러 요청에 걸친 트랜잭션을 만들지 말아야 한다. 여러 요청에 걸친 트랜잭션을 일반적으로 <strong>긴 트랜잭션</strong>이라고 한다.</p><p>따라서 요청이 시작될 때 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션을 끝내는 방법이 일반적으로 많이 사용된다. 이러한 <strong>요청 트랜잭션</strong>은 간단하고 깔끔한 모델이며, 여러 환경에서 메서드를 트랜잭션으로 지정하는 방법으로 간편한 선언식 트랜잭션을 지원한다.</p><p>다른 방법은 트랜잭션을 최대한 늦게 여는 것이다. 트랜잭션 밖에서 모든 읽기를 수행하고 업데이트를 시작할 때 트랜잭션을 여는 이 방식을 <strong>지연 트랜잭션</strong>이라고 한다. 따라서 일반적으로 이 기법은 충돌이 아주 심하거나 비즈니스 트랜잭션이 여러 요청에 걸치기 때문에 어쩔 수 업이 사용해야 하는 경우가 아니면 잘 사용되지 않는다.</p><p>트랜잭션을 사용할 때는 어떤 리소스가 잠기는지 어느 정도 인식하고 있어야 한다. 이 잠금 상향은 동시성에 상당히 심각한 영햐을 미친다. 도메인의 <strong>계층 상위 형식</strong> 레벨의 데이터 일부에 객체 테이블을 사용하지 않아야 하는 이유이기도 하다.</p><p><strong>활동성을 위한 트랜잭션 격리성 저하</strong></p><p>활동성을 개선하기 위해 트랜잭션의 보호 수준을 제한하는 경우를 흔히 볼 수 있다. 여러 트랜잭션을 동시에 실행하도 순서대로 실행했을 때와 동일한 결과를 얻을 수 있는 경우 직렬화 가능 트랜잭션이라고 말한다.</p><p>대부분의 트랜잭션 시스템은 SQL 표준을 사용해 네 가지 격리 수준을 정의한다.</p><p><a href="https://www.notion.so/d322e38316f241229f1c3c9229238ce2">제목 없음</a></p><p>정확성을 최대한 보장하려면 항상 직렬화 가능 격리 수준을 사용해야 한다. 그러나 직렬화 가능을 사용하면 시스템의 활동성이 크게 저하되므로 처리량을 늘리려면 어쩔 수 없이 직렬화 가능성을 어느 정도 포기해야 한다. 즉, 어느 수준까지 위험을 감수할지 결정하고 오류와 성능 간의 적절한 균형을 찾는 것이 중요하다.</p><p>모든 트랜잭션에 동일한 격리 수준을 사용해야 하는 것은 아니므로 각 트랜잭션에 맞게 활동성과 정확서의 균형을 결정할 수 있다.</p><p><strong>비즈니스 트랜잭션과 시스템 트랜잭션</strong></p><p>이 책에서 지금까지 알아본 트랜잭션은 <strong>시스템 트랜잭션</strong>이라고 하며, RDBMS 시스템과 트랜잭션 모니터의 지원을 받아 운영된다.</p><p>그러나 시스템 트랜잭션은 비즈니스 시스템의 사용자에게는 전혀 의미가 없다. 이를 <strong>비즈니스 트랜잭션</strong>이라고 하며, 여기서도 시스템 트랜잭션과 동일한 ACID 속성을 제공해야 한다.</p><p>즉, 여러 시스템 트랜잭션 사이에서 비즈니스 트랜잭션의 ACID 특성을 지원하는 역할을 여러분이 직접 담당해야 하며, 앞에서 오프라인 동시성이라고 소개한 문제를 해결해야 한다.</p><p>애플리케이션이 도메인 모델을 사용하는 경우 작업 단위로 정확하게 변경을 추척할 수 있다. 비즈니스 논리를 트랜잭션 스크립트에 넣은 경우 수동으로 변경 사항을 추적할 수 있다. 비즈니스 논리를 트랜잭션 스크립트에 넣을 경우 수동으로 변경 사항을 추적해야 하지만 트랜잭션 스크립트를 사용한다는 것은 비즈니스 트랜잭션이 간단하다는 의미이기도 하므로 변경 사항을 추적하는 것은 크리 큰 문제는 아닐 것이다.</p><p>비즈니스 트랜잭션에서 적용하기 까다로운 ACID 속성은 격리다. 애플리케이션이 단일 트랜잭션 안에서 일관성을 유지하기 위해서 해야 하는 역할은 모든 사용 가능한 비즈니스 규칙을 적용하는 것이다. 애플리케이션이 단일 트랜잭션 안에서 일관성을 유지하기 위해 해야 하는 역할은 모든 사용 가능한 비즈니스 규칙을 적용하는 것이다. 그리고 여러 트랜잭션에 걸쳐 일관성을 유지하기 위해 해야 하는 역할은 세션이 다른 세션의 변경 내용을 망치고 레코드 집합이 잘못된 상태가 되어 사용자의 작업이 손실되지 않도록 방지하는 것이다.</p><p>업데이트 충돌이라는 분명한 문제도 있지만, 일관성 없는 읽기라는 더 미묘한 문제가 있다.</p><p><strong>6. 오프라인 동시성 제어를 위한 패턴</strong></p><p>오프라인 동시성을 처리하는 첫 번째 선택은 여러 비즈니스 트랜잭션에 걸쳐 낙관적 동시성 제어를 사용하는 <strong>낙관적 오프라인 잠금</strong>이다. 낙관적 오프라인 잠금의 한계는 비즈니스 트랜잭션이 실패하는 경우 커밋할 때가 되서야 알 수 있다는 것인데, 이러한 늦은 잘견은 경우에 따라 상당한 불편함을 초래할 수 있다. 비관적 오프라인 잠금은 이에 대한 대안으로서 문제가 있으면 조기에 알아낼 수 있지만 프로그래밍하기 어렵고 활동성이 제한된다.</p><p>이러한 두 접근 방식을 사용할 때 모든 객체의 잠금을 직접 관리하려고 하지 않으면 복잡도를 크게 낮출 수 있다. <strong>굵은 입자 잠금</strong>을 사용하면 객체 그룹의 동시성을 함께 관리할 수 있다. 또한 <strong>암시적 잠금</strong>을 사용하면 애플리케이션 개발자의 부담을 크게 덜 수 있다.</p><p>낙관적 또는 비관적 제어의 결정은 시스템의 전체 사용자 경험에 영향을 미친다. 또한 비관적 오프라인 잠금을 현명하게 설계하려면 시스템의 사용자에게서 도메인에 대한 정보를 충분히 얻어야 한다. 마찬가지로 <strong>굵은 입자 잠금</strong>을 적절하게 선택하려면 도메인 지식이 필요하다.</p><p><strong>7. 애플리케이션 서버 동시성</strong></p><p>동시성의 다른 형태로 애플리케이션 서버 자체의 프로세스 동시성이 있다. 이 동시성 문제에서는 서버가 여러 동시 요청을 어떻게 처리하며, 이것이 서버의 애플리케이션 설계에 어떤 영향을 미치는지 고려한다.</p><p>가장 간단한 방법은 각자의 프로세스에서 실행되는 <strong>세션별 프로세스</strong>를 사용하는 것이다.</p><p>세션별 프로세스에서 한 가지 문제는 프로세스가 리소스를 너무 많이 소모한다는 것이다. 그래서 각 프로세스를 한 번에 한 요청만 처리할 수 있지만, 다른 세션의 여러 요청을 순차적으로 처리할 수 있도록 프로세스의 풀을 만들어 효율을 높이는 방법이 나왔다,. 이처럼 풀링되는 <strong>요청별 프로세스</strong>를 이용하면 일정 수의 세션을 처리하는 데 훨씬 적은 수의 프로세스가 사용된다.</p><p>그런데 요청별 프로세스 방식도 일정 수준의 부하를 처리하려면 많은 프로세스를 실행해야 한다. 한 프로세스가 여러 스레드를 실행하게 하면 처리량을 개선할 수 있다. 이러한 <strong>요청별 스레드</strong> 방식에서 각 요청은 프로세스 내의 한 스레드에 의해 처리된다. 요청별 스레드 방식의 문제는 스레드가 서로 격리되지 않기 때문에 어떤 스레드든지 접근 가능한 데이터를 변경할 수 있다.</p><p>가장 권장하고 싶은 방식은 요청별 프로세스다. 요청별 스레드보다는 효율이 낮지만 요청별 프로세스도 확장성이 충분하다. 또한 견고성이 더 우수하다.</p><p>요청별 스레드를 사용할 때 가장 시급한 것은 애플리케이션 개발자가 다중 스레드 문제를 걱정할 필요가 없는 격리된 지역을 만들고 이를 호라용하는 것이다.</p><p>객체를 생성하는 비용은 사용하는 가상 시스템과 메모리 관리 전략에 따라 크게 좌우된다. 실제로 최신 환경에서 객체 생성속도는 사실 상당히 빠르다. 각 세션마다 새로운 객체를 만들면 많은 동시성 버그를 예방하고 확장성을 개선할 수 있다.</p><p>이 전술은 여러 경우에 적용이 가능하지만 개발자가 피해햐 하는 몇 가지 영역이 있다. 하나는 정적, 클래스 기반 변수가 전역 변수다. 이러한 변수에 대한 접근은 모두 동기화해야 한다. 싱글턴의 경우도 마찬가지다.</p><p>전역 메모리와 비슷한 기능이 필요하면 레지스트리를 사용한다.</p><p><strong>8. 참고자료</strong></p><p>이 단원은 여러 면에서 복잡한 주제를 간단하게 소개하는 수준이었다. 이 주제를 본격적으로 알아보려면 [Bernstein and Newcomer], [Lea], [Schmidt et al.]을 추천한다.</p><p><strong>6장. 세션 상태</strong></p><p><strong>1. 상태 비저장의 가치</strong></p><p>가장 우선적인 문제는 서버 리소스에 대한 것이다. 모든 상태 저장 서버 객체는 사용자가 웹 페이지를 보는 동안 대기하면서 모든 상태를 유지해야 한다. 반면 상태 비저장 서버 객체는 다른 세션의 다른 요청을 처리할 수 있다.</p><p><strong>2. 세션 상태</strong></p><p>세션 상태는 필자가 레코드 데이터라고 부르는 것과 구분된다. 레코드 데이터는 데이터베이스에 저장되는 장기 보존 데이터이며, 모든 세션에서 볼 수 있다. 세션 상태는 커밋을 거쳐야 레코드 데이터가 된다.</p><p>세션 상태는 한 비즈니스 트랜잭션에 포함되므로 ACID와 같이 여러 사람들이 트랜잭션의 속성이라고 생각하는 속성을 가진다.</p><p>한 가지 흥미로운 영향은 동시성이다. 세션 상태는 이와 같이 작업 중인 동안에는 유효성 검사 규칙과 맞지 않는 경우가 많다. 비즈니스 트랜잭션이 커밋할 때만 유효성 검사 규칙과 맞게 된다.</p><p>세션 상태와 관련된 가장 중요한 문제는 격리성이다. 세션이 저장하는 모든 데이터가 세션 상태인 것은 아니다. 세션은 요청 간에 꼭 저장해야 할 필요가 없는 데이터도 성능 향상을 위해 캐싱할 수 있다. 세션 상태는 올바른 동작을 위해 요청 간에 저장해야 하지만 캐시는 손실되더라도 올바른 동작에 방해되지 않는다.</p><p><strong>3. 세션 상태를 저장하는 방법</strong></p><p>클라이언트 세션 상태는 데이터를 클라이언트에 저장한다.</p><p>서버 세션 상태는 요청 간에 데이터를 메모리에 저장하는 간단한 방법일 수 있다. 그러나 일반적으로는 세션 상태를 직렬화된 객체와 같이 더 안정적으로 저장할 수 있는 메커니즘이 사용된다.</p><p>데이터베이스 세션 상태도 역시 서버 쪽 자정소지만 오랫동안 보관할 데이터를 저장하듯이 데이터를 테이블과 필드로 분리하고 데이터베이스에 저장하는 방식이다.</p><p>먼저 클라이언트와 서버 간에 필요한 대역폭을 고려해야 한다.</p><p>정리하자면, 저장해야 하는 세션 상태의 양이 아주 적지 않으면 클라이언트 세션 상태는 사용하지 않는 것이 좋다. 보안과 무결성도 고려해야 한다. 데이터를 제대로 암호화하지 않으면 악성 사용자가 세션 데이터를 편집해 심각한 범죄를 일으킬 수 있다.</p><p>세션 데이터는 격리해야 한다. 대부분의 경우 한 세션에서 일어나는 일은 다른 세션에서 일어나는 일에 영향을 미치지 않아야 한다. 이 사실은 데이터베이스 세션 상태를 사용할 때는 데이터베이스에 저장된 레코드 데이터로부터 세션 데이터를 격리하기 위해 까다로운 작업이 필요할 수 있다는 의미다.</p><p>사용자 수가 많은 경우 처리량을 향상하기 위해 클러스터링을 도입하는 것을 고려할 수 있다. 이 경우 마이그레이션이 필요한지 생각해야 한다. 이와 반대되는 개념은 한 서버가 특정 세션의 모든 요청을 처리하게 하는 서버 선호도다. 세션 마이그레이션을 사용하면 특히 세션이 길게 유지되는 경우 서버가 처리하는 부하를 균형 있게 배분할 수 있다. 그런데 서버 세션 상태를 사용할 때는 세션을 처리하는 시스템만 해당 상태를 쉽게 찾을 수 있는 경우가 많기 때문에 불편한 상황에 처할 수 있다. 이를 해결하는 몇 가지 방법이 있는데, 이러한 방법을 사용하면 데이터베이스 세션 상태와 서버 세션 상태 간의 구분이 흐려진다.</p><p>이것은 대형 인터넷 서비스 업체의 IP 주소 때문에 트래픽의 상당수가 한 서버로 집중될 수 있다는 의미이다.</p><p>서버가 세션 상태를 사용하려면 이를 신속하게 사용할 수 있는 형태로 만들어야 한다. 서버 세션 상태의 경우 세션 상태는 거의 바로 사용 가능하다. 클라이언트 세션 상태의 경우에도 바로 얻을 수는 있지만 원하는 형태로 만들어야하는 경우가 많다. 데이터베이스 세션 상태의 경우 데이터베이스에서 세션 상태를 가져오고 원하는 형태로 만들어야 한다.</p><p>여러 시스템에서 숨은 문제점 중 하나는 사용자가 세션을  취소하고 다시 돌아오지 않을 수 있다는 것이다. 클라이언트 세션 상태는 사용자에 대해 크게 신경 쓸 필요가 없기 때문에 이런 상황에 적합하다. 다른 패턴을 사용할 때는 사용자가 세션 상태를 취소했다고 판단되는 경우 세션 상태를 지워야 하며, 일정 시간 제한이 지나면 취소하는 시스템을 마련해야 한다.</p><p>사용자 취소만이 아니라 시스템의 문제도 고려해야 하는데, 이러한 문제에는 클라이언트 강제 종료, 서버 오류, 그리고 네트워크 연결 실패가 있다. 데이터베이스 세션 상태는 이 세 가지 상황에 잘 대처할 수 있다. 서버 세션 상태는 세션 객체가 비휘발성 저장소에 백업됐는지 여부와 저장소 위치에 따라 대처 여부가 결정된다. 클라이언트 세션 상태는 클라이언트 강제 종료에는 대처할 수 없지만 나머지 두 문제에는 대처할 수 있다.</p><p>이러한 패턴을 구현하기 위한 개발 작업의 어려움도 중요한 고려사항이다. 서버 세션 상태는 일반적으로 가장 쉽게 개발할 수 있으며, 요청 간에 세션 상태를 지속할 필요가 없는 경우 특히 더 쉽다. 데이터베이스 세션 상태와 클라이언트 세션 상태의 경우 일반적으로 데이터베이스에 읽은 형식을 변환하거나 세션 객체가 사용할 형식을 변환하는 코드가 필요하다. 특히 데이터가 복잡하다면 서버 세션 상태를 사용할 때만큼 신속하게 다른 여러 기능을 개발할 수 없다는 의미이다.</p><p>세 방식은 상호배타적인 방식이 아니며, 두 방식 또는 세 방식을 혼합해 세션 상태의 다른 부분을 저장할 수 있다.</p><p><strong>7장. 분산 전략</strong></p><p><strong>1. 분산 객체의 매력</strong></p><p>투명성은 가치고 높고, 분산 객체의 여러 측면에 긍정적 영향을 주지만 일반적으로 성능에는 긍정적 영향을 주지 않는다. 설계자가 성능을 위해서라고 설명한 설계로 프로토타입 아키텍처를 구현하고 객체를 분산해도 실제로는 성능이 오히려 저하되며 시스템의 구축이나 배포도 훨씬 어려워진다.</p><p><strong>2. 원격 및 로컬 인터페이스</strong></p><p>따라서 원격으로 사용할 객체의 인터페이스는 같은 프로세스 내에서 로컬로 사용할 객체의 인터페이스와는 달라야 한다.</p><p>로컬 인터페이스는 가는 입자 인터페이스일 때 가장 좋다. 가는 입자 인터페이스가 바람직한 이유는 당야한 방법으로 재정의하고 결합해 향후에 설계를 확장할 수 있는 작은 조각으로 정의하는 객체지향의 일반적 규칙을 따르기 때문이다.</p><p>그런데 가는 입자 인터페이스는 원격 환경에는 잘 맞지 않는다. 메서드 호출이 느리기 때문에 시, 도, 우편번호를 한 번의 호출에 한꺼번에 얻거나 업데이트하고 싶을 것이기 때문이다. 결과적으로 인터페이스는 유연성이느 확장성이 아닌 호출 횟수 최소화를 위한 굵은 입자 인터페이스가 된다.</p><p>원격으로 사용되지 않는 모든 객체는 가는 입자 인터페이스를 가져야 함에도 우너격으로 사용될 수 있는 모든 객체가 굵은 입자 인터페이스를 갖게 된다는 결과를 피할 수 없다.</p><p>이러한 이유로 원래보투 단일 프로세스의 세게에 맞게 설계한 클래스 그룹에는 단순희 코바 등의 기술을 적용한 후 분산 모델로 만들 수는 없다.</p><p>그래서 필자는 “객체를 분산하지 말라”를 분산 객체 설계의 첫 번째 규칙으로 제시한다.</p><p>일반적으로는 클러스터링이 가장 적합하다. 모든 클래스를 단일 프로세스에 넣고 해당 프로세스의 여러 복사본을 다수의 노드에서 실행하는 것이다.</p><p><strong>3. 분산이 필요한 상황</strong></p><p>한 가지 확실한 분리는 비즈니스 소프트웨어에서 전통적인 클라이언트와 서버 간의 분리다.</p><p>두 번째 분리는 서버 기반 애플리케이션 소프트웨어와 데이터베이스 간에 자주 볼 수 있다.</p><p>웹 시스템에서 웹 서버와 애플리케이셔 서버 간에도 프로세스의 분리가 필요할 수 있다.</p><p>공급업체 간의 차이 때문에 분리해야 할 수 있다. 소프트웨어 패키지는 일반적으로 자체 프로세스 안에서 실행되므로 이를 사용하는 경우에도 분산이 적용된다.</p><p>그리고 마지막은 애플리케이션 서버 소프트웨어를 분리해야 하는 합당한 이유가 있는 경우다. 가능한 모든 방법으로 동원해 이런 경우를 예방해야 하겠지만 어쩔 수 없이 소프트웨어를 분리해야 하는 순간에는 마음을 굳게 먹고 원격의 굵은 입자 컴포넌트로 나눈다.</p><p><strong>4. 분산 경계를 사용한 작업</strong></p><p>그 핵심은 내부적으로는 가는 입자 객체를 사용하고 이에 대한 원격 인터페이스를 제공하는 굵은 입자 객체를 분산 경계에 배치하는 것이다. 굵은 입자 객체는 위임 외의 다른 일은 하지 않으므로 가는 입자 객체에 대한 파사드라고 할 수 있다. 이 파사드는 분산 용도로만 사용되므로 원격 파사드라고 한다.</p><p>원격 파사드를 이용하면 굵은 입자 인터페이스를 사용할 때의 어려움을 최소화하는 데 도움이 된다.</p><p>데이터 전송 객체는 원격 파사드와 밀접하게 연관되며 주로 함께 사용된다. 굵은 입자 메서드 입자만 필요한 것이 아니라 굵은 입자 객체를 전송하는 기능도 필요하다. 일반적으로 도메인 객체 자체를 전송할 수는 없다. 도메인 객체는 가는 입자의 로컬 객체 간 참조와 복잡한 구조와 밀접하게 연결돼 있기 때문이다. 따라서 클라이언트가 필요로 하는 모든 데이터를 가져와 전송하기에 적합한 객체, 즉 데이터 전송 객체를 만들어야 한다. 데이터 전송 객체는 전송 전후 양쪽에서 모두 사용되므로 양쪽에서 공유하지 않는 것을 참조하지 않아야 한다. 결국 데이터 전송 객체는 일반적으로 다른 데이터 전송 객체와 문자열 등의 기본 객체만 참조하게 된다.</p><p>브로커를 통해 객체를 프로세스 간에 마이그레이션해 분산을 구현하는 방법도 있다. 기본 개념은 데이터베이스에서 지연 읽기를 수행하는 대신 지연 로드 체계를 사용해 객체를 전송하는 것이다.</p><p><strong>5. 분산을 위한 인터페이스</strong></p><p>분산 컴포넌트의 인터페이스는 전통적으로 원격 프로시저 호출에 기반을 두는 경우가 많다.</p><p>XML 기반 HTTP 통신에는 여러 장점이 있다. 가장 큰 장점은 많은 양의 데이터를 구조화된 형식을 통해 단 한 번의 오아복으로 손쉽게 전송할 수 있다는 것이다. XML은 여러 플랫폼에서 지원되는 파서로 구문 분석이 가능한 공용 포맷이며, HTTP는 사실상 거의 어디서나 범용 표준으로 통용되므로 다양한 플랫폼에서 기 기법을 기반으로 한 시스템을 구축할 수 있다. 또한 XML은 기본적으로 텍스트 형식이므로 전송 중인 내용을 확인하기도 쉽다. 또한 HTTP는 보안이나 정치적 이유로 다른 포트를 열기 어려울 때 방화벽을 통과하기도 쉽다.</p><p>클래스와 메서드의 객체지향 인터페이스에도 나름대로 가치가 있다. 전송된 모든 데이터를 XML 구조와 문자열로 옮기는 과정은 원격 호출에 적지 않은 부담이 된다. 두 시스템이 동일한 플랫폼에 구축된 경우 해당 플랫폼이 기본 제공하는 원격 호출 메커니즘을 사용하는 것이 좋다. 서로 다른 플랫폼 간에 통신을 수행하는 데는 웹 서비스가 유용하다.</p><p>물론 객체지향 인터페이스 위에 HTTP 인터페이스 계층을 추가해 양쪽 세계의 장점을 취하는 방법도 있다.</p><p>그런데 사실 필자는 동기식 RPC 기반 인터페이스가 분산 시스템을 운영하는 최상의 방법이라고 생각하지는 않는다. 이보다는 근본적으로 비동기적인 메시지 기반 방식이 더 좋다고 생각하고 있다. 이 주제를 전문적으로 다루는 책이 곧 나오기를 바라지만 현재로서는 비동기 메시지 기반 방식에 관심을 가지라고 조언할 수 있을 뿐이다.</p><p><strong>8장. 종합</strong></p><p><strong>1. 도메인 계층으로 시작하기</strong></p><p>프로세스의 시작은 어떤 도메인 논리를 사용할지 선택하는 것이다. 여기에 고려할 수 있는 세 가지 패턴은 트랜잭션 스크립트, 테이블 모듈, 그리고 도메인 모델이다.</p><p><strong>2. 데이터 원본 계층</strong></p><p>도메인 계층을 선택하고 나면 데이터 원본과 연결하는 방법을 알아내야 한다. 데이터 원본과 연결하는 방법은 도메인 계층의 선택에 따라 달라지므로 이 선택별로 각기 다른 절로 나눠 설명한다.</p><p><strong>트랜잭션 스크립트의 데이터 원본</strong></p><p>가장 단순한 트랜잭션 스크립트의 경우 자체 데이터베이스 논리를 포함할 수 있지만 필자는 아무리 간단한 애플리케이션에서도 데이터베이스를 분리하는 방법을 사용한다. 이 경우 선택할 수 있는 데이터베이스 패턴은 행 데이터 게이트웨이와 테이블 데이터 게이트웨이다.</p><p><strong>테이블 모듈의 데이터 원본</strong></p><p>테이블 모듈을 선택하는 주된 이유는 좋은 레코드 집합 프레임워크가 있기 때문이다. 이 경우 레코드 집합과 잘 맞는 데이터베이스 매핑 패턴이 필요하므로 테이블 데이터 게이트웨이가 매력적인 선택이다.</p><p><strong>도메인 모델의 데이터 원본</strong></p><p>지금부터 흥미로워진다. 도메인 모델의 가장 큰 약점은 데이터베이스에 대한 연결이 복잡하다는 것이다.</p><p>도메인 모델이 아주 간단하면, 예를 들어 데이터베이스와 아주 비슷한 20여 개의 클래스를 사용하는 경우 활성 레코드를 선택하는 것이 합리적이다.</p><p>결합을 느슨하게 만들려면 테이블 데이터 게이트웨이나 행 데이터 게이트웨이를 사용하면 된다.</p><p>이보다 더 복잡한 경우 도메인 모델을 다른 모든 계층으로부터 최대한 독립적으로 운영하기 위해 데이터 매퍼를 사용하는 것을 고려해야 한다.</p><p><strong>3. 프레젠테이션 계층</strong></p><p>프레젠테이션 계층은 여러 측면에서 상대적으로 하위 계층에서 무엇을 선택하느냐와는 큰 관계가 없다. 첫 번째 질문은 리치 클라이언트 인터페이스와 HTML 브라우저 인터페이스 중 무엇을 선택하느냐다. 필자를 가급적이면 HTML 브라우저를 선택하고 이것이 불가능한 경우 리치 클라이언트를 선택한다.</p><p>HTML을 선택했다면 그 다음으로는 애플리케이션의 기본 구조를 선택해야 한다. 필자를 애플리케이션의 기본 설계로 모델 뷰 컨트롤러를 가장 우선적으로 추천한다.</p><p>자바를 사용하는 경우 웹 프레임워크를 고려해볼 수 있다. 현재 가장 인기 있는 기술로 스트럿츠가 있으며, 이를 선택했다면 프런트 컨트롤러와 템플릿 뷰를 선택하면 적합하다.</p><p>좀더 자유롭게 선택할 수 있다면 사이트가 문서 기반이로 특히 정적 문서와 동적 문서가 혼재된 경우 페이지 컨트롤러를 추천한다. 그리고 복잡한 탐색과 UI가 필요한 경우 프론트 컨트롤러가 적합하다.</p><p>뷰에 템플릿 뷰와 변환 뷰 중 무엇을 선택할지는 팀에서 프로그래밍에 서버 페이지와 XSLT 중 무엇을 사용하느냐에 따라 달라진다.</p><p><strong>4. 몇 가지 기술 관련 조언</strong></p><p>다만 기술은 패턴보다 훨씬 빠른 속도로 발전하기 때문에 경우에 따라서는 설명하는 내용이 구식이 될 수 있다는 문제가 있음을 미리 알아두자.</p><p><strong>자바와 J2EE</strong></p><p>트랜잭션 스크립트를 일종의 게이트웨이 위에서 사용하는 경우, EJB를 선택했을 때 현재의 일반적인 방법은 세션 빈을 트랜잭션 스크립트로, 그리고 엔티티 빈을 행 데이터 게이트웨이로 사용하는 것이다.</p><p>도메인 모델을 사용하려면 현재는 엔티티 빈을 사용하는 것이 일반적이다. 도메인 모델이 아주 간단하고 데이터베이스와 잘 부합된다면 아주 적절한 서택이며, 엔티티 빈은 활성 레코드가 된다.</p><p>어떤 상황에서든 엔티티 빈을 사용할 때는 원격 인터페이스를 적용하지 않도록 주의하자.</p><p>테이블 모듈은 아직 자바 세계에서는 흔하지 않다. JDBC 행 집합과 관련된 툴이 더 선보인다면 이 패턴도 선택 가능한 방안이 될 수 있다.</p><p><strong>.NET</strong></p><p>.NET과 비주얼 스튜디오, 그리고 마이크로소프트 환경에서 애플리케이션 개발의 역사를 봤을 때 주된 패턴은 테이블 모듈이다.</p><p><strong>저장 프로시저</strong></p><p>저장 프로시저는 종종 논쟁거리가 된다. 저장 프로시저는 데이터베이스와 동일한 프로세스에서 실행되며, 느린 원격 호출을 줄일 수 있기 때문에 작업을 가장 빠르게 실행하는 방법일 수 있다. 그러나 대부분의 저장 프로시저 환경은 저장 프로시저를 구조화하는 좋은 메커니즘을 제공하지 않으며, 저장 프로시저를 사용하면 특정 데이터베이스 공급업체로 고착되는 문제가 있다.</p><p>물론 명확한 성능상 문제가 있을 때만 이 방법을 사용하며, 아키텍처 원칙이라기보다는 최적화 단계 중 하나로 생각한다.</p><p><strong>웹서비스</strong></p><p>웹서비스는 애플리케이션 구축보다 통합을 위한 것이기 때문에 전체 패턴에서 차지하는 비중이 그리 높지는 않다. 중요한 것은 꼭 필요한 경우가 아니면 한 애플리케이션을 서로 통신하는 웹 서비스로 분할하지 않아야 한다는 것이다. 이보다는 애플리케이션을 구축하고 여러 부분을 웹 서비스로 노출하고 웹 서비스를 원격 파사드로 취급하는 것이 좋다.</p><p><strong>5. 다른 계층화 체계</strong></p><p>먼저 [Brown et al.]에 소개된 브라운 모델에 대해 알아보자. 이 모델은 프레젠테이션, 컨트롤러/중재자, 도메인, 데이터 매핑, 데이터 원본의 다섯 개 계층으로 이뤄지며, 기본적인 세 계층 사이에 두 주재 계층이 추가된 형식이다. 컨트롤러/중재자는 프레젠테이션과 도메인 계층을 중재하며, 데이터 매핑 계층은 도메인과 데이터 원본 계층을 중재한다.</p><p>[Alur et al.]에서는 J2EE에 적합한 코어 J2EE라는 계층을 소개했다. 이 모델은 클라이언트, 프레젠테이션, 비즈니스, 통합, 리소스의 다섯 계층으로 이뤄진다. 비즈니스 계층은 도메인 계층과, 통합 계층은 데이터 원본 계층과 간단하게 대응된다. 리소스 계층은 통합 계층이 연결하는 외부 서비스로 구성된다.</p><p>마이크로소프트 DNA 설계자인 [Kirtland]는 필자의 세 계층과 거의 그대로 일치하는 프레젠테이션, 비즈니스, 데이터 접근으로 구성된 세 계층 체계를 정의했다.</p><p>[Marinescu]는 다섯 계층으로 이뤄진 모델을 제시했다. 이 모델에서는 애플리케이션 컨트롤러를 분리해 프레젠테이션을 두 개의 계층으로 나눴다. 도메인 역시 도메인 계층을 두 부분으로 나누는 일반적인 아이디어를 반영해 도메인 모델과 이에 기반을 두는 서비스 계층으로 나눴다. 이 방식은 EJB를 도메인 모델로 사용할 때 적용되는 제한을 고려한 일반적인 방식이다.</p><p>[Nilsson]은 좀 더 복잡한 계층화 체계를 선보였다. 닐슨은 저장 프로시저를 광범위하게 사용했고 성능상 이유로 저장 프로시저 안에 도메인 논리를 넣는 것을 장려했기 때문에 닐슨의 체계와 매핑하는 작업은 다소 복잡하다.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on August 4, 2022</p><ul class="post__tag"><li><a href="https://publii.wisehouse.kr/tags/martin-fowler/">Martin Fowler</a></li><li><a href="https://publii.wisehouse.kr/tags/poeaa/">PoEAA</a></li></ul><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://publii.wisehouse.kr/authors/jung-chul-woo/" rel="author">Jung, Chul Woo</a></h3></div></div></footer></article></main><footer class="footer"><div class="footer__copyright">Powered by Publii</div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://publii.wisehouse.kr/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://publii.wisehouse.kr/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>